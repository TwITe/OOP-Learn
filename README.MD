# Краткий справочник по ООП

## Вступление
Данный справочник призван помочь в освоении ООП. Вся информация приведена в простом и понятном виде.

---

### Содержание:
- [Парадигмы программирования](https://github.com/TwITe/OOP-Tutorial#%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
    * [Императивное](https://github.com/TwITe/OOP-Tutorial#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D1%82-%D0%B2-%D1%81%D0%B5%D0%B1%D1%8F-%D0%B8%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5)
    * [Декларативное](https://github.com/TwITe/OOP-Tutorial#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D1%82-%D0%B2-%D1%81%D0%B5%D0%B1%D1%8F-%D0%B4%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5)
- [Что такое ООП? Зачем оно нужно? Как оно используется?](https://github.com/TwITe/OOP-Tutorial#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%9E%D0%9E%D0%9F-%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%9A%D0%B0%D0%BA-%D0%BE%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F)
- [Как проектировать программы с ООП?](https://github.com/TwITe/OOP-Tutorial#%D0%9A%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D1%81-%D0%9E%D0%9E%D0%9F)
- [Базовые принципы ООП](https://github.com/TwITe/OOP-Tutorial#%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F)
- [Что такое класс?](https://github.com/TwITe/OOP-Tutorial#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%81)
- [В чем различия между классом, структурой и объединением?](https://github.com/TwITe/OOP-Tutorial#%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%BC-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BE%D0%B9-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC)
- [Что такое объект?](https://github.com/TwITe/OOP-Tutorial#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82)
- [Отличия между классом и объектом](https://github.com/TwITe/OOP-Tutorial#%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%BC-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%BC)
- [Модификаторы доступа](https://github.com/TwITe/OOP-Tutorial#%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0)
    * [public](https://github.com/TwITe/OOP-Tutorial#public)
    * [private](https://github.com/TwITe/OOP-Tutorial#private)
    * [protected](https://github.com/TwITe/OOP-Tutorial#protected)
- [Виртуальные функции](https://github.com/TwITe/OOP-Tutorial#%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
    * [Чистая виртуальная функция](https://github.com/TwITe/OOP-Tutorial#%D0%A7%D0%B8%D1%81%D1%82%D0%B0%D1%8F-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
- [Таблица виртуальных функций](https://github.com/TwITe/OOP-Tutorial#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9)
- [Friend functions](https://github.com/TwITe/OOP-Tutorial#%D0%94%D1%80%D1%83%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-friend-functions)
- [Статические поля класса](https://github.com/TwITe/OOP-Tutorial#%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)
- [Статические методы класса](https://github.com/TwITe/OOP-Tutorial#%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)
- [Scope resolution operator](https://github.com/TwITe/OOP-Tutorial#scope-resolution-operator-)
- [Конструктор](https://github.com/TwITe/OOP-Tutorial#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80)
    - [Default constructor](https://github.com/TwITe/OOP-Tutorial#default-constructor)
    - [Parameterized constructor](https://github.com/TwITe/OOP-Tutorial#parameterized-constructor)
- [Вызов конструктора](https://github.com/TwITe/OOP-Tutorial#%D0%92%D1%8B%D0%B7%D0%BE%D0%B2-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%B0)


---

### Краткий словарь терминов
- **Полиморфизм** - это способность функций вызывать необходимую реализацию в зависимости от типа данных. В данном справочнике будет рассмотрен
 **Runtime** полиморфизм.
- **Метод** - методом называется функция какого-либо класса
- **Поле класса** - полем называется какая-либо переменная класса

---

## Парадигмы программирования

Прежде чем приступать к изучению ООП и ответу на вопрос зачем оно нужно, сначала надо изучить
самые основные парадигмы и понять разницу между ними.

**Парадигма** - это стиль написания программ, подходы к написанию кода.

Парадигмы делятся на 2 типа: **императивное** и **декларативное**.

Императивная парадигма программированию задает последовательность команд, КАК надо что-то сделать,
а декларативное - только то, ЧТО надо сделать.

**[Wikipedia](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Декларативное программирование"):**
> В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к человеку.

### Основные парадигмы, которые включает в себя императивное:

#### **Процедурное программирование**
Наиболее популярная парадигма, используемая большинством людей. Вся программа - набор переменных, их состояний,
они постоянно меняются пока программа идет к конечному результату.
Программа содержит набор подпрограмм (процедур), с помощью которых вычисляются нужные значения, меняются какие-то переменные.
В языках C и C++ их роль выполняют функции.

#### **Объектно-ориентированное программирование**
Данная парадигма будет рассмотрена позднее более подробно

### Основные парадигмы, которые включает в себя декларативное:

#### **Функциональное программирование**
Абсолютно противоположная императивному парадигма. Тут нет переменных, нет состояний.
Новые переменные создаются путем передачи нужных аргументов в функции, где уже создаются новые значения, а из тех же функций снова в другие.
Поэтому основной принцип работы программы - рекурсия.
Это защищает данные от изменения, так как на каждм шаге программы мы работает всегда с новыми данными, и повлиять на
прошлые никак не можем. То есть программа работает только с локальными данными, передаваемыми в функции.

---

## Что такое ООП? Зачем оно нужно? Как оно используется?
ООП включает в себя все процедурное программирование.
Однако, оно решает самую главную проблему процедурного программирования - в процедурном значения переменных могут меняться извне,
потому что они доступны глобально. Вызывая какие-нибудь функции, мы рискуем повлиять на работу совершенно других
переменных/функций. ООП же, в свою очередь, завязан на работе только с отдельными объектами.
Это защищает данные от внезапного изменения, так как вызывая какой-нибудь метод, пользователь работает лишь с конкретным объектом.

---

## Как проектировать программы с ООП?
1. Как и приступая к написанию кода большинства программ, для начала следует разобраться с архитектурой программы,
продумать все алгоритмы, а не сразу начинать писать код, треубется полностью понять как должна работать будущая программа.

2. Стоит помнить о такой вещи в ООП, как принцип единственной ответственности. Каждый класс должен быть ответственен только
за одну вещь и отвечать за конкретную цель. Потому что при изменении кода в одном месте, это может затронуть
совершенно дргуие функции, изменение которых пользователь может совершенно не ожидать, так как они преследуют совершенно
другие цели, но из-за того, что все реализовано в одном классе, мы рискуем получить ошибку.
При чем, принцип единственной ответственности предпологает, что вся важнейшая реализация будет инкапсулирована.

3. Программа должна быть разбита на отдельные модули, каждый модуль отвечает за отдельные вещи.
При чем, они должны быть связаны минимально, то есть изменение кода в одном классе должно быть относительно безболезненным, 
чтобы потом не пришлось переделывать всю программу.

4. Программа должна быть читабельна, а структура программы понятна, не должно быть анархии в коде.
Один из способов сделать это - это при написании программы следует отделять интерфейс программы от их реализации, 
инкапсулируя реализацию нижнего уровня, а также ненужную информацию, которая потребуется лишь в ходе работы
самой программы, то есть вещи которые происходят внутри нее, но не в ходе ее использования, предоставляя лишь нужный 
интерфейс к доступу функций.

---

## Базовые принципы ООП

 1. **Наследование** - это возможность создать новый дочерний класс на основе родительского класса, но расширением функционала.
 При чем, все методы родительского класса будут доступны и в дочерном.

Пример:
```c++
#include <iostream>
using namespace std;

class base_class {
public:
    string s;

    void initialize_string(const string& data) {
        s = data;
    }
};

class derived_class: public base_class { // пример наследования: был создан дочерный класс с доступными

    // методами класса-родителя, но расширением функционала
public:
    void print_string() {
        cout << s;
    }
};

int main() {
    derived_class object;
    object.initialize_string("derived class was created");
    object.print_string(); // derived class was created
    return 0;
}
```

 2. **Полиморфизм** - это возможность использовать объекты c одинаковым интерфейсом одного класса, но на основе типа объекта.
	Это значит то, что основной интерфейс у них не отличается ничем друг от друга, но некоторые методы должны
	работать в зависимости от типа объекта. Тогда создается несколько методов, имеющих одинаковое объявление, но
	различную реализацию, внутри одного класса и его потомков.
	Более подробно данная особенность будет рассмотрена позднее в главе "Виртуальные функции".

Пример:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << endl <<  "Base class print function was called";
    }
};

class Derived : public Base {
public:
    void print() override { // Пример полиморфизма: функция была объявлена ранее в родительском классе,
        // однако при вызове функции print() из объекта типа Derived будет вызвана данная функция, а не
        // родительского класса
        cout << endl << "Derived class print function was called";
    }
};

int main () {
    Base* parent = new Base;
    Derived child;
    parent->print(); // Base class print function was called
    cout << endl;
    delete parent;
    parent = &child; // Смена типа объекта на тип дочерного класса
    parent->print(); // Derived class print function was called
    return 0;
}
```

 3. **Инкапсуляция** - это сокрытие деталей реализации в классе. Доступ к необходимым данным предоставлен через паблик методы.

Пример:
```c++
#include <iostream>
#include <cmath>
using namespace std;

class Rectangle {
protected:
    double width, height;
public:
    void set_values(int a, int b) {
        width = a;
        height = b;
    }

    double get_area() { // Объявлена паблик функция получения площади прямоугольника, однако ее
    // реализация скрыта
        area();
    }

    double get_diagonal() { // Аналогично
        diagonal();
    }

private:
    double area() { // Реализация функции получения площади скрыта и защищена от изменений
        return width * height;
    }

    double diagonal() { // Аналогично
        return sqrt(pow(width, 2) + pow(height, 2));
    }
};

int main () {
    Rectangle figure = Rectangle();
    figure.set_values(4, 10);
    cout << figure.get_area() << endl; // 40
    cout << figure.get_diagonal(); // 10.7703
    return 0;
}
```

---

## Что такое класс?

**Класс** - это тип данных, определяемый пользователем. Мы сами задаем тип, а значит можем добавлять к типу свои методы,
переменные, сами задаем его реализацию.

**Создание класса**

```c++
#include <iostream>
using namespace std;

class example {
public:
    string s = "class was created";
    int a = 19;
    return 0;
};
```

---

## В чем различия между классом и структурой?

Класс от структуры отличает то, что в классе все элементы *по умолчанию* скрыты (private), а в структуре открыты (public).

---

## Что такое объект
**Объект** - это конкретный экземпляр класса, функциональность которого полностью ограничена самим классом. Класс - всего лишь описание, на него не
выделяется памяти. Для того, чтобы стало возможным записывать данные и вызывать методы, требуется создать объект. Все состояния переменных класса
будут принадлежать конкретному объекту (кроме статических полей, они будут рассмотрены позднее).

Создание объекта:

```c++
#include <iostream>
using namespace std;

class example {
public:
    string s = "object was created";
    int a = 19;
};

int main() {
    example created_object; // Объект создан
    return 0;
}
```

---

## Отличия между классом и объектом
Класс лишь определяет доступные поведения, методы, возможные состояния экземпляров класса (объектов), а сами объекты -
это конкретные экземпляры класса, в них мы можем вызывать методы, создавать переменные, при чем все они могут иметь 
различные состояния, но будут контролироваться классом. Все доступные методы и поведение описано в классе, через объекты
происходит взаимодействие с классом и хранение данных.

---

## Модификаторы доступа

Модификаторы доступа позволяют настраивать область видимости в программе конкретных методов/переменных, описанных в классе.
Они бывают трех типов:
### **Public**

Данный модификатор позволяет получать доступ к переменным/методам из любого места программы. Никакие данные не скрыты,
область видимости - глобальная.

Пример:

```c++
class example {
public:
    string s;
    int a;
};

int main() {
    example obj;
    obj.s = "class was created"; //здесь мы напрямую обращаемся к переменной класса
    cout << obj.s;
    return 0;
}
```

### **Private**

Данный модификатор ограничивает область видимости переменных/методов, делая их доступными только в самом классе.
Доступ к ним можно будет получить только через паблик методы класса.

Пример:

```c++
#include <iostream>
using namespace std;

class example {
private:
    string s;
public:
    void initialize_string(const string& data) {
        s = data;
    }
    void print_string() {
        cout << s;
    }
};

int main() {
    example obj;
    //obj.s = "private access is set"; //Ошибка: Мы пытаемся получить доступ к переменной вне области
    //видимости класса.
    obj.initialize_string("private modifier is set"); // Для того, чтобы получить доступ к переменной,
    // объявленной как private, нужно обращаться к ней через паблик функции в классе
    obj.print_string(); // private modifier is set
    return 0;
}
```

### **Protected**
Данный модификатор отличается от private только тем, что данные, объявленные как protected, могут быть получены из
дочерних классов, созданных на основе родительского (также это известно как наследовние, разобранное и описанное выше).

Пример:
```c++
#include <iostream>
using namespace std;

class example {
//private: // Ошибка: мы не сможем получить доступ к переменной в дочерном классе
protected:
    string s;
};

class child_class_of_example:example {
public:
    void initialize_string(const string& data) {
        s = data;
    }
    void print_string() {
        cout << s;
    }
};

int main() {
    child_class_of_example object;
    object.initialize_string("protected modifier is set");
    object.print_string(); // protected modifier is set
    return 0;
}
```

---

## Виртуальная функция

**Виртуальная функция** - это метод в родительском классе, который можно переопределить в его дочерних классах. Это позволяет
 пользователю вызывать необходимые методы в зависимости от типа объекта (см. [Базовые принципы ООП: Полиморфизм](https://github.com/TwITe/OOP-Learn#%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F)).

 Пример:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << "In parent class";
    }

    void print_non_virtual_function() {
        cout << "In parent class";
    }

};

class Derived:public Base {
public:
    void print() override {
        cout << "In child class";
    }

    void print_non_virtual_function() {

        cout << "In child class";
    }
};

int main () {
    Base* baseptr;
    Derived derivedptr;

    baseptr = &derivedptr; // Объект типа дочерного класса

    baseptr->print(); // In child class
    cout << endl;
    baseptr->print_non_virtual_function(); // In parent class
    cout << endl;

    baseptr = new Base; // Объект типа родительского класса

    baseptr->print(); // In parent class
    cout << endl;
    baseptr->print_non_virtual_function(); // In parent class
    delete baseptr;
    return 0;
}
```

Как видно из примера, функция **print_non_virtual_function()**, вызванная из объекта типа **Derived**, все равно вызывает функцию из
родительского класса. Это происходит потому, что функция **print_non_virtual_function()** вызывается в зависимости от типа *указателя*,
а не объекта. Виртуальные функции же решают эту проблему и позволяют вызывать методы на основе типа *объекта*, что и происходит с
функцией **print()**, объявленной как *virtual*.

Объявив функцию print_non_virtual_function() как виртуальную:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << "In parent class";
    }

    virtual void print_non_virtual_function() {
        cout << "In parent class";
    }

};

class Derived:public Base {
public:
    void print() override {
        cout << "In child class";
    }

    void print_non_virtual_function() override {

        cout << "In child class";
    }
};

int main () {
    Base* baseptr;
    Derived derivedptr;

    baseptr = &derivedptr; // Объект типа дочерного класса

    baseptr->print(); // In child class
    cout << endl;
    baseptr->print_non_virtual_function(); // In child class // Проблема решена: метод вызвался, соответствуя типу объекта
    cout << endl;

    baseptr = new Base; // Объект типа родительского класса

    baseptr->print(); // In parent class
    cout << endl;
    baseptr->print_non_virtual_function(); // In parent class
    delete baseptr;
    return 0;
}
```

В главе [Базовые принципы ООП: Полиморфизм](https://github.com/TwITe/OOP-Learn#%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F) функции вызывались в зависимости от типа объекта по указателю,
инициализированному при компиляции программы и больше не меняясь, что называется **Compile time polymorhism**.
Виртуальные функции же, в свою очередь, позволяют при смене указателю на другой тип, вызывать методы, переопределенные для текущего типа объекта, *по ходу работы всей программы*, что
называется **Runtime polymorphism**.

---

### Чистая виртульная функция

**Чистая виртульная функция** - это виртуальная функция, не имеющая имплементации в родительском классе. Необходимость в ней возникает, когда пользователь не знает,
какая имплементация должна быть у виртуальной функции в родительском классе, так как ее имплементация зависит от типа объекта. Чистая виртульная функция инициализируется
нулевым значением.

 Пример:
```c++
#include <iostream>
#include <cmath>
using namespace std;

class Shape {
protected:
    int width = 0, height = 0;
public:
    void set_values(int a, int b) {
        width = a;
        height = b;
    }
    virtual double get_diagonal() = 0; // Тип объекта не известен (квадрат или прямоугольник),
    // соответственно имплементация метода в родительском классе невозможна
};

class Square:public Shape {
public:
    double get_diagonal() override {
        return sqrt(2 * pow(width, 2));
    }
};

class Rectangle:public Shape {
public:
    double get_diagonal() override {
        return sqrt(pow(width, 2) + pow(height, 2));
    }
};

int main () {
    Shape* shape;
    Square square;
    Rectangle rectangle;
    shape = &square;
    shape->set_values(5, 5);
    cout << shape->get_diagonal() << endl; // 7.07107
    shape = &rectangle;
    shape->set_values(4, 3);
    cout << shape->get_diagonal(); // 5
    return 0;
}
```

---

## Таблица виртуальных функций

Как было уже сказано ранее, виртуальные функции поддерживают **Runtime** полиморфизм. Он реализуется автоматически компилятором с помощью
виртуальной таблицы функций. Говоря кратко, виртуальная таблица класса - это список указателей на методы, которые должны будут вызываться,
в зависимости от типа объекта. Виртуальная таблица создается для каждого класса, который имеет виртуальный метод, или для унаследованных от него.
Если виртульная функция была переопределена в классе, то виртуальная таблица для данного класса будет иметь указатель на метод в данном классе,
иначе указатель будет иметь адрес метода в классе, в котором виртуальный метод был впервые объявлен (в основном, родительский класс).

---

## Friend functions

**Friend function** - это функция, объявленная вне области класса и его потомков, однако имеющая доступ к скрытым данным (private и protected) в нем.

 Пример:
 ```c++
#include <iostream>
using namespace std;

class Base {
private:
    int a;
public:
    friend void print_value(Base base); // Объявление дружественной функции (keyword "friend")

    int set_values(int value) {
        a = value;
    }
};

void print_value(Base base) { // Дружественная функция, имеющая доступ к скрытым данным в классе Base
    cout << base.a;
}

int main () {
    Base base = Base();
    base.set_values(5);
    print_value(base); // 5
    return 0;
}
 ```

---

## Статические поля класса

**Статическое поле** - это переменная, которая имеют общее состояние во всех созданных объектах. Это означает то, что при изменении значения
переменной в одном объекте, она изменится и во всех созданных объектах того же типа класса.

Пример:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    static int s;
};

int Base::s = 0;

int main() {
    Base first;
    Base second;
    first.s = 5;
    cout << first.s; // 5
    cout << endl;
    cout << second.s; // 5
    // Переменная s во втором объекте имеет то же состояние, что и первый объект
    return 0;
}
```

 Наверняка, у вас возник вопрос, для чего нужна такая инициализация переменной?
```c++
int Base::s = 0;
```
Так как статическая переменная не является частью конкретных объектов, а принадлежит самому классу, то и инициализируется она при начале работы
программы. Также, если класс со статическим полем определен в хедере, то при включении хедера во множественных местах, переменная будет объявляться
более одного раза, что запрещено. Поэтому ее определение требуется вынести за область видимости класса.

- Еще одной особенностью статических полей является то, что пользователь может получить к ним доступ, даже не создавая объект. Такой метод доступа
к данным наиболее предпочтителен, чем доступ через объекты, так как корректнее считать, что статическое поле относится к самому *классу*, а не к
конкретному *объекту*.

Пример:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    static int s;
};

int Base::s = 0;

int main() {
    Base::s = 5;
    cout << Base::s; // 5
    return 0;
}
```

- Также следует отметить, что при *инициализации* доступ к статической переменной может быть получен независимо от ее модификаторов доступа.

- Еще одной важной особенностью является то, что статическая переменная хранит свое состояние от начала работы программы и до конца.

---

## Статические методы класса
**Статический метод** - статический метод так же, как и статическая переменная, может быть вызван без создания объекта. Также он нужен для того,
чтобы получить доступ к скрытым статическим полям в классе, так как получить доступ к скрытой переменной напрямую невозможно (но ее все также можно
инициализировать). Для того, чтобы это стало возможным, требуется создать статический класс.

Пример:
```c++
#include <iostream>
using namespace std;

class Base {
private:
    static int s;
public:
    static int get_value() {
        return s;
    }
};

int Base::s = 10;

int main() {
    cout << Base::get_value(); // 10
    return 0;
}
```

- Следует отметить, что статический метод может получить доступ только к таким же *static* полям класса, но не *non-static* переменным.

- Также определение метода может быть вынесено за область видимости класса. Пример:
```c++
#include <iostream>
using namespace std;

class Base {
private:
    static int s;
public:
    static int get_value();
};

int Base::get_value() {
    return s;
}

int Base::s = 10;

int main() {
    cout << Base::get_value(); // 10
    return 0;
}
```

---

## Scope resolution operator ::
Оператор :: позволяет получать доступ к области видимости какого-либо класса, и, соответственно, к
переменным/методам в нем.

---

## Конструктор
**Конструктор** - это специальный метод класса, который инициализирует объекты. Конструктор вызывается автоматически при создании объекта.
Если пользователь не написал свой конструктор, компилятор автоматически генерирует пустой конструктор, где все переменные инициализируются
нулевыми значениями.

Существует 2 типа конструкторов:

### Default constructor
**Стандартный конструктор** - это конструктор, который не имеет никаких параметров.

Пример:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    int a, b;

    Base() { // Конструктор
    // Параметров нет
        a = 5;
        b = 7;
    }
};

int main () {
    Base construct;
    cout << construct.a; // 5
    cout << endl;
    cout << construct.b; // 7
    return 0;
}
```

### Parameterized constructor
**Parameterized constructor**, в отличие от стандартного конструктора, имеет параметры в своем объявлении и позволяет инициализировать поля класса
переданными параметрами.

Пример:
```c++
#include <iostream>
using namespace std;

class Base {
public:
    int a, b;

    Base(int a1, int a2) {
        a = a1;
        b = a2;
    }
};


int main () {
    Base construct(10, 15);
    cout << construct.a; // 10
    cout << endl;
    cout << construct.b; // 15
    return 0;
}
```

### Вызов конструктора
Вызвать конструктом можно двумя способами:
- Для *стандартного* конструктора:
```c++
    Construct explicit_call = Construct(); // Явный вызов
    Construct implicit_call; // Неявный вызов
```

- Для *parameterized* конструктора:
```c++
    Construct explicit_call = Construct(arg1, arg2); // Явный вызов
    Construct implicit_call(arg1, arg2); // Неявный вызов
```

### Initialization list

---

## Что такое деструктор?
**Деструктор** - это специальный метод класса, который освобождает память и уничтожает объект. ***Если деструктор имплементирован***, он вызывается
автоматически при выходе объекта из области видимости или при освобождении динамической памяти, где был создан объект. Деструктор требуется для
того, чтобы произвести другие необходимые действия перед тем, как объект полностью уничтожится. Например, закрыть открытый файл, высвободить
динамически выделенную память и т.д.

Пример простого деструктора:
```c++
#include <iostream>
using namespace std;

class Destruct {
public:
    int a = 5, b = 10;

    ~Destruct() {
        cout << "Object was deleted";
    }
};


int main () {
    Destruct example;
    return 0; // Object was deleted
}
```

### Виртуальный деструктор