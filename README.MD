##                                Краткий справочник по ООП

Содержание:

[Парадигмы программирования](https://github.com/TwITe/OOP-Learn#%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

[Что такое ООП? Зачем оно нужно? Как оно используется?](https://github.com/TwITe/OOP-Learn#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%9E%D0%9E%D0%9F-%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%9A%D0%B0%D0%BA-%D0%BE%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F)

[Как проектировать программы с ООП?](https://github.com/TwITe/OOP-Learn#%D0%9A%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D1%81-%D0%9E%D0%9E%D0%9F)

[Базовые принципы ООП](https://github.com/TwITe/OOP-Learn#%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F)

[Что такое класс?](https://github.com/TwITe/OOP-Learn#%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%81)

[В чем различия между классом, структурой и объединением?](https://github.com/TwITe/OOP-Learn#%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%BC-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BE%D0%B9-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC)

[Отличия между классом и объектом](https://github.com/TwITe/OOP-Learn#%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%BC-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%BC)

[Модификаторы доступа](https://github.com/TwITe/OOP-Learn#%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0)


## Парадигмы программирования

Прежде чем приступать к изучению ООП и ответe на вопрос? зачем оно нужно, сначала надо изучить
 самые основные парадигмы и понять разницу между ними.

**Парадигма** - это стиль написания программ, подходы к написанию кода.

Парадигмы делятся на 2 типа: **императивное** и **декларативное**.

Императивная парадигма программированию задает последовательность команд, КАК надо что-то сделать,
а декларативное - только то, ЧТО надо сделать.

Цитата с [вики](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Декларативное программирование"), наиболее точно объясняющую разницу между ними:
> В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к человеку.

#### Основные парадигмы, которые включает в себя императивное:

**Процедурное программирование** - наиболее популярная парадигма, используемая большинством людей. Вся программа - набор переменных,
их состояний, они постоянно меняются пока программа идет к конечному результату. 
Программа содержит набор подпрограмм (процедур), с помощью которых вычисляются нужные значения, меняются какие-то переменные.
В языках C и C++ их роль выполняют функции.

**Объектно-ориентированное программирование** - будет рассмотрена позднее

#### Основные парадигмы, которые включает в себя декларативное:

**Функциональное программирование** - абсолютно противоположная императивному парадигма. Тут нет переменных, нет состояний.
Новые переменные создаются путем передачи нужных аргументов в функции, где уже создаются новые значения, а из тех же функций снова в другие.
Поэтому основной принцип работы программы - рекурсия.
Это защищает данные от изменения, так как на каждм шаге программы мы работает всегда с новыми данными, и повлиять на
прошлые никак не можем. То есть программа работает только с локальными данными, передаваемыми в функции.


## Что такое ООП? Зачем оно нужно? Как оно используется?
Данная парадигма включает в себя все процедурное программирование.
Однако, оно решает самую главную проблему процедурного программирования - в процедурном значения переменных могут меняться извне,
потому что они доступны глобально. Вызывая какие-нибудь функции, мы рискуем повлиять на работу совершенно других
переменных/функций. ООП же, в свою очередь, завязан на работе только с отдельными объектами.
Это защищает данные от внезапного изменения, так как вызывая какой-нибудь метод, пользователь работает лишь с конкретным объектом.


## Как проектировать программы с ООП?
1. Как и приступая к написанию кода большинства программ, для начала следует разобраться с архитектурой программы,
продумать все алгоритмы, а не сразу начинать писать код, треубется полностью понять как должна работать будущая программа.

2. Стоит помнить о такой вещи в ООП, как принцип единственной ответственности. Каждый класс должен быть ответственен только
за одну вещь и отвечать за конкретную цель. Потому что при изменении кода в одном месте, это может затронуть
совершенно дргуие функции, изменение которых пользователь может совершенно не ожидать, так как они преследуют совершенно
другие цели, но из-за того, что все реализовано в одном классе, мы рискуем получить ошибку.
При чем, принцип единственной ответственности предпологает, что вся важнейшая реализация будет инкапсулирована.

3. Программа должна быть разбита на отдельные модули, каждый модуль отвечает за отдельные вещи.
При чем, они должны быть связаны минимально, то есть изменение кода в одном классе должно быть относительно безболезненным, 
чтобы потом не пришлось переделывать всю программу.

4. ООП программы должны писаться по принципу "сверху-вниз". Сначала проектируются модули верхнего уровня
(пока не уделяя времени реализации в нижнем уровне, а подходя к нижнему уровню постепенно). Пишутся самые
основные модули. А вместо недостающих функций пишутся заглушки - функции, реализованные самым простейшим образом.
Такаим образом логика программы видна намного яснее.

Если есть такой принцип, то существует и принцип, противоположный данному - "снизу-вверх". Сначала пишутся функции
нижнего уровня, постепенно переходя к высшему уровню. Но вот проблема. Допустим, пользователь написал все функции, остается только
раскидать и упаковать все по отдельным модулям. Но функций то много, не понятно какие к чему относятся, в общем, хаос.
А также, если вдруг окажется, что верхний уровень плохо совмести с функциями нижнего уровня, или вообще глупая реализация 
нижнего, потому что дальнейшая стратегия объединения в модули не продумана, то придется все переделывать.

5. Программа должна быть читабельна, а структура программы понятна, не должно быть анархии в коде.
Один из способов сделать это - это при написании программы следует отделять интерфейс программы от их реализации, 
инкапсулируя реализацию нижнего уровня, а также ненужную информацию, которая потребуется лишь в ходе работы
самой программы, то есть вещи которые происходят внутри нее, но не в ходе ее использования, предоставляя лишь нужный 
интерфейс к доступу функций.

---

## Базовые принципы ООП

 1. **Абстракция данных** -
 Каждому объекту придаются какие-то особые состояния, характеристики, процедуры, которые потребуются по ходу работы 
	программы. Это и отличает каждый объект от всех остальных и как раз это самая важный принцип ооп - разделение на объекты.

 2. **Наследование** - это возможность создать новый класс на основе какого-то класса, заимствовая методы из родительского
	класса.

 3. **Полиморфизм** - это возможность использовать объекты c одинаковым интерфейсом одного класса, но на основе типа объекта.
	Допустим, есть несколько объектов, в основном, интерфейс у них не отличается ничем друг от друга, но некоторые методы должны
	работать в зависимости от типа переменной. И тогда можно создать несколько методов внутри одного класса сразу для нескольких типов.

 4. **Инкапсуляция** - это скрытие деталей реализации. Пользователь всего лишь будет обращаться к объектам через интерфейс,
	а реализицию видеть будет нельзя. Вся реализация - инкапсулирована (скрыта, неизменяема вне области видимости самого класса),
	а доступ к данным предоставлен только через интерфейс.

---

## Что такое класс?

Класс -  это тип данных, определяемый пользователем. Мы сами задаем тип, а значит можем добавлять к типу свои методы,
переменные, сами задаем его реализацию.

Существуют классы 3 видов:
* **struct (структура)**
* **class (собственно сам класс)**
* **union (объединение)**

**Создание класса**

```c++
#include <iostream>
using namespace std;

class example {
public:
    string s = "class was created";
    int a = 19;
};
```

## В чем различия между классом, структурой и объединением?

Класс от структуры отличает то, что в классе все элементы по умолчанию скрыты (private), а в структуре открыты (public).
Объединения нужны для того, чтобы максимизировать производительность программы, и уменьшить использование памяти.
При создании структуры выделяется память сразу на все переменные, а в объединении выделяется память только для самых больших по
размеру занимаемой памяти типов.
И далее этот же участок памяти будет использоваться для других переменых при их инициализации.
 Естественно, старые данные при этом потеряются, так что их использование объединений предпологает то, что
 старые данные больше никогда не понадобятся.

## Что такое объект
Объект - это переменная, которые полностью копируют класс, типом которого они являтся. Когда объявляется класс, на него не выделяется
памяти, в нем нельзя хранить данные. Для того, чтобы это стало возможно, требуется создать переменную, типом которой является
данный класс. Данная переменная и будет являться объектом. Функционал объекта полностью ограничен самим функционалом класса.

Создание объекта:

```c++
#include <iostream>
using namespace std;

class example {
public:
    string s = "class was created";
    int a = 19;
};

int main() {
    example created_object; // Объект создан
}
```

## Отличия между классом и объектом
Класс лишь определяет доступные поведения, методы, возможные состояния экземпляров класса (объектов), а сами объекты -
это конкретные экземпляры класса, в них мы можем вызывать методы, создавать переменные, при чем все они могут иметь 
различные состояния, но будут контролироваться классом. Все доступные методы и поведение описано в классе, через объекты
происходит взаимодействие с классом и хранение данных.

## Модификаторы доступа

Модификаторы доступа позволяют настраивать область видимости в программе конкретных методов/переменных, описанных в классе.
Они бывают трех типов:
* **public** -
Данный модификатор позволяет получить доступ к переменным/методам из любого места программы. Никакие данные не скрыты,
область видимости - глобальная.

Пример:

```c++
class example {
public:
    string s;
    int a;
};

int main() {
    example obj;
    obj.s = "class was created"; //здесь мы напрямую обращаемся к переменной класса
    cout << obj.s;
}
```

* **private** -
Данный модификатор ограничивает область видимости переменных/методов, делая их доступными только в самом классе.
Доступ к ним можно будет получить только через паблик методы класса.

Пример:

```c++
#include <iostream>
using namespace std;

class example {
private:
    string s;
public:
    void initialize_string(const string& data) {
        s = data;
    }
    void print_string() {
        cout << s;
    }
};

int main() {
    example obj;
    //obj.s = "private access is set"; //Ошибка: Мы пытаемся получить доступ к переменной вне области
    //видимости класса.
    obj.initialize_string("private modifier is set"); // Для того, чтобы получить доступ к переменной,
    // объявленной как private, надо обращаться к ней через паблик функции в классе
    obj.print_string(); // private modifier is set
    return 0;
}
```

* **protected** - данный модификатор отличается от private только тем, что данные, объявленные как protected, смогут быть получены из
классов потомков, созданных на основе родительского (также это известно как наследовние, разобранное и описанное выше).

Пример:
```c++
#include <iostream>
using namespace std;

class example {
//private: // Ошибка: мы не сможем получить доступ к переменной в дочерном классе
protected:
    string s;
public:
};

class child_class_of_example:example {
public:
    void initialize_string(const string& data) {
        s = data;
    }
    void print_string() {
        cout << s;
    }
};

int main() {
    child_class_of_example object;
    object.initialize_string("protected modifier is set");
    object.print_string(); // protected modifier is set
    return 0;
}
```


