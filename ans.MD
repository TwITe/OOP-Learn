##                                Краткий справочник по ООП

### Что такое ООП? Зачем оно нужно? Как оно используется? Как проектировать программы с ООП?

Прежде чем приступать к изучению ООП и ответа на вопрос зачем оно нужно, сначала надо изучить
другие, самые основные парадигмы и разницу между ними.

Парадигма - это стиль написания программ, подходы к написанию кода.

Парадигмы делятся на 2 типа: императивное и декларативное.

Императивная парадигма программированию задает последовательность команд, КАК надо что-то сделать,
а декларативное - только то, ЧТО надо сделать.

Цитата с [вики](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0
%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), наиболее точно объясняющую разницу между ними:
> В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к человеку.

#### Основные парадигмы, которые включает в себя императивное:

**Процедурное программирование** - наиболее популярная парадигма, используемая большинством людей. Вся программа - набор переменных,
их состояний, они постоянно меняются пока программа идет к конечному результату. 
Программа содержит набор подпрограмм (процедур), с помощью которые вычисляются нужные значения, меняются какие-то переменные.
В си и си++ я так их роль выполняют обычные функции.

**Объективно-ориентированное программирование** - эта парадигма включает в себя все процедурное программирование.
То есть функции, набор и последовательность каких-то команд.
Но решает самую главную проблему процедурного программирования - в процедурном значения переменных могут меняться извне, 
потому что они могут быть доступны глобально, то есть если мы вызывает какую нибудь функцию - у нее есть доступ ко всем 
переменным в global scope. То есть, как на саму функцию так и сама она может влиять извне на переменные, и как результат
могут возникнуть ошибки, тем более когда кода много, а функции используются всеми и везде, трудно будет отследить ошибку. 
То есть, в процедурном данные и подпрограммы никак не связаны, то есть относятся ко всему и вызвать можно будет везде.
Так вот, ооп завязано на работе с отдельными объектами и только, только с ними. Это защищает данные от внезапного изменения,
потому что доступ к ним может быть закрыт (флаг private), и другие функции изменять данные не относящиеся никак не смогут. 
Также, вызывая функцию какого либо класса мы всего лишь говорим что делать, это безопасный уровень, в отличие от процедурного,
где мы явно говорили, как сделать, тут это будет реалзивано в самом классе, и повлиять на это никак нельзя будет. 
То есть, ООП связывает в одно целое все данные и нужные функции, избавляя от ненужных и защищая данные.
А доступ к функциям и переменные внутри объекта будет происходить через интерфейс, но реализацию видеть будет нельзя.

#### Основные парадигмы, которые включает в себя декларативное:

**Функциональное программирование** - абсолютно противоположно императивному. Тут нет переменных, нет состояний.
В императивном на каждом шаге программы меняются значения аргументов, программа имеет состояния аргументов. 
То есть на какие-то вычисления влияют многие вещи извне, потому что все данные могут меняться, 
а функциональное программировани как раз решает эту проблему: объекты не меняются вообще, 
а только создаюся новые путем передачи нужных аргументов в функции, где уже создаются новые значения. 
То есть программа работает только с локальными данными, передаваемыми в функции.

---

### Как проектировать программы с ООП?
1. Как и приступая к написанию кода большинства программ, для начала следует разобраться с архитектурой программы,
продумать все алгоритмы, а не сразу начинать писать код, полностью понять как должна работать твоя будущая программа.

2. Стоит помнить о такой вещи в ООП, как принцип единственной ответственности. Каждый класс должен быть ответственен только
за одну вещь, нельзя например сделать класс в котором будут реализованы как сохранение, так и загрузка данных. Потому что 
при изменении архитектуры и кода функции сохранения, это может затронуть и загрузку, так как все реализовано в одном классе.
При чем, принцип единственной ответственности, также предпологает что все функции сохранения будут инкапсулированы 
(скрыты, private флаг).

3. Программа должна быть разбита на отдельные модули, каждый модуль отвечает за отдельные вещи.
При чем, они должны быть связаны минимально, то есть изменение кода в одном классе должно быть относительно безболезненным, 
чтобы не пришлось потом вообще переделывать всю программу.
4. ООП программы должны писаться по принципу "сверху-вниз". То есть сначала проектируются модули верхнего уровня
(пока не уделяя времени реализации в нижнем уровне, а подходя к нижнему уровню постепенно). То есть сначала пишутся самые 
основные модули. А вместо пока недостающих функций пишутся заглушки - функции реализованные самым простейшим образом.
Такаим образом видна намного яснее логика твоей программы. Где какие функции должны быть, какой класс отвечает за что, все 
уже объединено, остается только написать уже оставшуюся более сложную и лучшую имплементацию функций, при чем их семантика 
тебе уже известна, потому что ты видишь всю логику своей программы.
Если есть такой принцип, то офк существует и принцип, противоположный данному - "снизу-вверх". Сначала пишутся функции 
нижнего уровня, постепенно переходя к высшему уровню. Но вот проблема. Окей, ты написал все функции, остается только 
раскидать и упаковать все по отдельным модулям. А функций то дохуя, куда что сувать, кто и кого вызывает, в общем хаос. 
А также, если вдруг окажется, что верхний уровень плохо совмести с функциями нижнего уровня, или вообще глупая реализация 
нижнего, потому что ты нифига не продумал как ты вообще все это свяжешь, то придется все переделывать. Так что, херня этот 
принцип.
5. пятых, программа должна быть читабельна, а структура программы понятна, не должно быть анархии в коде.
Один из способов сделать это - это при написании программы следует отделять интерфейс программы от их реализации, 
скрывая реализацию нижнего уровня (private), и скрывая ненужную информацию, которая потребуется лишь в ходе работы 
самой программы, то есть вещи которые происходят внутри нее, но не в ходе ее использования, предоставляя лишь нужный 
интерфейс к доступу функций.


---

## Какие 3 базовых приниципа ооп и что это такое (наследование, полиморфизм, инкапсуляция)
 **Базовые принципы ООП:**

 1. **Абстракция данных** -
 Каждому объекту придаются какие-то особые состояния, характеристики, процедуры, которые потребуются по ходу работы 
	программы. Это и отличает каждый объект от всех остальных и как раз это самая важная вещь ооп - разделение на объекты.

 2. **Наследование** - это возможность создать новый класс на основе какого-то класса, заимствовая методы из родительского
	класса, то есть у нас был какой то основной объект, но там не достает каких то методов, которые нужны будут новому объекту,
	да, можн  создать новый класс, но будет дублирование кода, да и вообще это не логично, потому что не будет соблюдаться 
	главное правильно - абстракция. Каждый класс должен быть действительно уникальным. Ну какой смысл ради 1-2 методов создавать
	новый класс, вот и тут мы просто на основе какого-то класса создаем новый, дополняя родительский под свои нужды.

 3. **Полиморфизм** - это возможность использовать объекты c одинаковым интерфейсом одного класса, но на основе типа объекта.
	То есть есть очень похожие объекты, некоторый интерфейс у них ничем не отличается от друг друга, но все таки есть некоторые
	отличия.
Да, можно было бы создать 3 класса под каждый тип, но тогда произойдет дублирование кода, потому что у них есть одинаковые 
функции и переменные. Это и решает полиморфизм - вместо создания 3 классов, мы можем создать 1 класс, а внутри в зависимости
от типа сделать производные методы отноосящиеся к какому то конкретно типу объекта. 

 4. **Инкапсуляция** - это скрытие деталей реализации. То есть мы всего лишь будет обращаться к объектам через интерфейс,
	а реализицию видеть будет нельзя. Объект будет скрыт от действий извне, вся реализация - внутри, а доступ только через 
	интерфейс.

---

## Что такое класс

Класс -  это тип данных, определяемый пользователем. Мы сами задаем тип, а значит можем добавлять к типу свои методы,
переменные, сами задаем его реализацию.
Существуют классы 3 видов:
* **struct (структура)**
* **class (собственно сам класс)**
* **union (объединение)**

Класс от структуры отличает то, что в классе все элементы по умолчанию скрыты (private), а в структуре открыты (public).
Объединения я так понял нужны для того, чтобы максимизировать производительность программы, и особенно, что и является 
главным отличием от остальныъ типов классов, уменьшить использование памяти. То есть при создании структуры, 
там выделяется сразу память на все переменные каких-то типов, а в объединении выделится память только для самых больших по
размеру занимаемой памяти типов.
И далее этот же участок памяти будет использоваться для других переменых, при обращении к ним,то есть все данные будут 
записываться в тот же участок. Естественно, старые данные при этом потеряются, так что их использование (unions) 
предпологает что тебе больше не понадобятся старые данные.

## Что такое объект
Объект, это структура данных, которая взаимодействует с определенным классом, хранит в себе переменные и их состояния. 
То есть когда мы пишем класс, мы всего лишь пишем реализацию будущих объектов которые будут объявлены как экземпляр класса
(эти понятия - объект и экземпляр класса - взаимозаменямы). Можно объявить много экземпляров класса, и все они могут быть
уникальны, но их поведение, доступные методы, доступные переменные будут полностью контролироваться классом. 
То есть, класс определяет возможные и доступные состояния и методы объектов. Как бы класс это глобальное определение,
а его конкретные индивидуальные вариации состояний - это объекты. 

## Отличия между классом и объектом
Класс определяет доступные поведения, методы, возможные состояния экземпляров класса (объектов), а сами объекты - 
это конкретные экземпляры класса, в них мы можем вызывать методы, создавать переменные, при чем все они могут иметь 
различные состояния, но будут контролироваться классом. Все доступные методы и поведение описано в классах, через объекты 
мы лишь взаимодействуем с классом. Простой пример приведу, вот есть структура данных строка - мы же не изменяем сам класс, 
в котором реализована строка? Мы создаем отдельный объект, и там уже взаимодейстуем с самим классом и его методами, типо 
find(), size(). clear() и т.д. Все состояния будут различнымиЮ длина строки, сами символы в строке, все различно между 
раздичными объектами, но ничего своего мы не добавляем в реализацию, лишь используем возможности класса. так и тут,
в экземплярах класса - как я уже сказал, класс - это тип, задаваемый самим же пользователем. 
И все также мы создаем отдельные объекты, все также используем доступные методы, а состояния различны, но все в пределах 
класса, где все это описано.

## Что такое модификаторы доступа - private, public и другие. Какие вообще бывают, когда какой из них нужно использовать

Модификаторы доступы определяет область
