1) что такое ооп? зачем оно нужно? как оно используется? как проектировать программы с ООП

Прежде чем приступать к изучению ООП, я решил сначала понять разницу между процедурным, функциональным, структурным и оо программированием (самые базовые), и что такое вообще парадигма, а также разницу между императивным и декларативным парадигмами.

Парадигма - это стиль написания программ, подходы к написанию кода.

Как я понял, императивная парадигма программированию задает последовательность команд, КАК надо что-то сделать,
а декларативное - только то, ЧТО надо сделать.
Отличный пример с вики:
В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к человеку. То есть декларативное - юзер хочет что-то, он говорит компьютеру что сделать, и не ебет как он это сделает, а императивное - человек говорит компьютеру, как делать все надо, задает нужную последовательность команд и сами команды.

Сначала разберемся с парадигмами, которые включает в себя императивное:

Процедурное программирование - это как раз то, какой парадигме я следую сейчас. Вся программа - набор переменных, их состояний, они постоянно меняются пока программа идет к конечному результату. Программа содержит набор подпрограмм (процедур), с помощью которые вычисляются нужные значения, меняются какие-то переменные. В си и си++ я так их роль выполняют обычные функции.

Объективно-ориентированное программирование - эта парадигма взяла в себя все процедурное программирование.
То есть функции, набор и последовательность киких-то команд. Но решает самую главную проблему процедурного программирования - в процедурном значения переменных могут меняться извне, потому что они могут быть доступны глобально, то есть если мы вызывает какую нибудь функцию - у нее есть доступ ко всем переменным в global scope. То есть, как на саму функцию так и сама она может влиять извне на переменные, и как результат могут возникнуть ошибки, тем более когда кода много, а функции используются всеми и везде, трудно будет отследить ошибку. То есть, в процедурном данные и подпрограммы никак не связаны, то есть относятся ко всему и вызвать можно будет везде.
Так вот, ооп завязано на работе с отдельными объектами и только, только с ними. Это защищает данные от внезапного изменения, 	потому что доступ к ним может быть закрыт (флаг private), и другие функции изменять данные не относящиеся никак не смогут. Также, вызываяфункцию какого либо класса мы всего лишь говорим что делать, это безопасный уровень, в отличие от процедурного, где мы явно говорили, как сделать, тут это будет реалзивано в самом классе, и повлиять на это никак нельзя будет. То есть, ООП связывает в одно целое все данные и нужные функции, избавляя от ненужных и защищая данные. А доступ к функциям и переменные внутри объекта будет происходить через интерфейс, а реализацию видеть будет нельзя.

Декларативное программирование:

Функциональное программирование - абсолютно противоположно императивному. Тут нет переменных, нет состояний. В императивном на каждом шаге программы меняются значения аргументов, программа имеет состояния аргументов. То есть на какие-то вычисления влияют многие вещи извне, потому что все данные могут меняться, а функциональное программировани как раз решает эту проблему: объекты не меняются вообще, а только создаюся новые путем передачи нужных аргументов в функции, где уже создаются новые значения. То есть программа работает только с локальными данными, передаваемыми в функции.

-----------------------------------------
какие 3 базовых приниципа ооп и что это такое (наследование, полиморфизм, инкапсуляция)
2) Базвые принципы ООП:
 1) Абстракция данные -
 Каждому объекту придаются какие-то особые состояния, характеристики, процедуры, которые потребуются по ходу работы программы. Это и отличает каждый объект от всех остальных и как раз это самая важная вещь ооп - разделение на объекты.

 2) Наследование - это возможность создать новый класс на основе какого-то класса, заимствовая методы из родительского класса, то есть у нас был какой то основной объект, но там не достает каких то методов, которые нужны будут новому объекту, да, можн  создать новый класс, но будет дублирование кода, да и вообще это не логично, потому что не будет соблюдаться главное правильно - абстракция. Каждый класс должен быть действительно уникальным. Ну какой смысл ради 1-2 методов создавать новый класс, вот и тут мы просто на основе какого-то класса создаем новый, дополняя родительский под свои нужды.

 3) Полиморфизм - это возможность использовать объекты c одинаковым интерфейсом одного класса, но на основе типа объекта. То есть есть очень похожие объекты, некоторый интерфейс у них ничем не отличается от друг друга, но все таки есть некоторые отличия.
Да, можно было бы создать 3 класса под каждый тип, но тогда произойдет дублирование кода, потому что у них есть одинаковые функции и переменные. Это и решает полиморфизм - вместо создания 3 классов, мы можем создать 1 класс, а внутри в зависимости от типа сделать производные методы отноосящиеся к какому то конкретно типу объекта. 

 4) Инкапсуляция - это скрытие деталей реализации. То есть мы всего лишь будет обращаться к объектам через интерфейс, а реализицию видеть будет нельзя. Объект будет скрыт от действий извне, вся реализация - внутри, а доступ только через интерфейс.